<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rebel Fork Framework: Math Cheatsheet</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rebel Fork Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__home_runner_work_rbfx-docs_rbfx-docs_pages_documentation_math-cheatsheet.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Math Cheatsheet </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Vector operations</h1>
<p>To convert one vector to another use the .To*Vector* operators. Here are few examples:</p>
<div class="fragment"><div class="line"><span class="comment">// Make IntVector2</span></div>
<div class="line"><span class="keyword">const</span> IntVector2 value{1, 2};</div>
<div class="line"><span class="comment">// Convert it to Vector2</span></div>
<div class="line"><span class="keyword">const</span> Vector2 vec2 = value.ToVector2();</div>
<div class="line"><span class="comment">// Convert it to Vector3, set Z component to 1</span></div>
<div class="line"><span class="keyword">const</span> Vector3 vec3 = value.ToVector3(1.0f);</div>
</div><!-- fragment --><p>To rotate vector by quaternion use the following:</p>
<div class="fragment"><div class="line"><span class="comment">// Make Vector3</span></div>
<div class="line"><span class="keyword">const</span> Vector3 vec3{1, 2, 3};</div>
<div class="line"><span class="comment">// Make Quaternion</span></div>
<div class="line"><span class="keyword">const</span> Quaternion quaternion(90, Vector3::UP);</div>
<div class="line"><span class="comment">// Rotate vector by quaternion</span></div>
<div class="line">Vector3 rotated = quaternion * vec3; <span class="comment">// The result is {3, 2, -1}</span></div>
</div><!-- fragment --><p>To transform vector with matrix use multiplication:</p>
<div class="fragment"><div class="line"><span class="comment">// Make Vector3</span></div>
<div class="line"><span class="keyword">const</span> Vector3 vec3{1, 2, 3};</div>
<div class="line"><span class="comment">// Make Matrix</span></div>
<div class="line"><span class="keyword">const</span> Matrix3 mat(90, Vector3::UP);</div>
<div class="line"><span class="comment">// Rotate vector by quaternion</span></div>
<div class="line">Vector3 rotated = mat * vec3; <span class="comment">// The result is {3, 2, -1}</span></div>
</div><!-- fragment --><p>If you use Matrix3x4 or Matrix4 but you only need to apply rotation and scale you can add a zero as W component and use multiplication:</p>
<div class="fragment"><div class="line"><span class="comment">// Make Vector3</span></div>
<div class="line"><span class="keyword">const</span> Vector3 vec3{1, 2, 3};</div>
<div class="line"><span class="comment">// Make Matrix</span></div>
<div class="line">Matrix3x4 mat{Matrix3{90.0f, Vector3::UP}};</div>
<div class="line">mat.SetTranslation(Vector3{10, 20, 30});</div>
<div class="line"><span class="comment">// Rotate and translate vector by matrix</span></div>
<div class="line">Vector3 translated = mat * vec3;  <span class="comment">// The result is {13, 22, 29}</span></div>
<div class="line"><span class="comment">// Rotate vector by matrix</span></div>
<div class="line">Vector3 rotated = mat * vec3.ToVector4(0.0f); <span class="comment">// The result is {3, 2, -1}</span></div>
</div><!-- fragment --><p>All rotations in the engine performed in a clockwise order. Here is what going to happen with a vector {x,y,z} if rotated around an axis at 90 degrees:</p>
<div class="fragment"><div class="line">Axis X (Vector::RIGHT):   { x, y, z } =&gt; { x,-z, y }</div>
<div class="line">Axis Y (Vector::UP):      { x, y, z } =&gt; { z, y,-x }</div>
<div class="line">Axis Z (Vector::FORWARD): { x, y, z } =&gt; {-y, x, z }</div>
</div><!-- fragment --><h1>Matrix operations</h1>
<p>In the engine, matrices are column-major (like in OpenGL) while in DirectX they are row-major.</p>
<p>In general, for a column-vector on the right (OpenGL convention), M1 * (M2 * (M3 * v)) = (M1 M2 M3) * v, i.e. the left-most matrix is at the root node while the right-most is at the leaf node.</p>
<div class="fragment"><div class="line"><span class="comment">// Make Vector3</span></div>
<div class="line"><span class="keyword">const</span> Vector3 vec3{1, 2, 3};</div>
<div class="line"><span class="comment">// Make rotation matrix</span></div>
<div class="line">Matrix3x4 rotation{Matrix3{90.0f, Vector3::UP}};</div>
<div class="line"><span class="comment">// Make translation matrix</span></div>
<div class="line">Matrix3x4 translation{Vector3{10,20,30}, Quaternion::IDENTITY, Vector3::ONE};</div>
<div class="line"><span class="comment">// Transform vector by matrix</span></div>
<div class="line">Vector3 rt = (rotation * translation) * vec3; <span class="comment">//33, 22, -11</span></div>
<div class="line">Vector3 expl = rotation * (translation * vec3); <span class="comment">//33, 22, -11</span></div>
<div class="line">Vector3 tr = (translation * rotation) * vec3; <span class="comment">//13, 22, 29</span></div>
</div><!-- fragment --><h2>Node transform matrices</h2>
<p>To combine world transform matrices to make a matrix that would transform from one game object space into another object space, you can multiply the inverse of the world transform matrix of the second object by the world transform matrix of the first object. This will give you a matrix that will transform from one object space to another object space.</p>
<p>Here is an example code: </p><div class="fragment"><div class="line">Matrix3x4 transformA = nodeA-&gt;GetWorldTransform();</div>
<div class="line">Matrix3x4 transformB = nodeA-&gt;GetWorldTransform();</div>
<div class="line">Matrix3x4 transformAtoB = transformB.Inverse() * transformA;</div>
<div class="line"><span class="keyword">const</span> Vector3 positionInA{1, 2, 3};</div>
<div class="line"><span class="keyword">const</span> Vector3 positionInB = transformAtoB * positionInA;</div>
</div><!-- fragment --><p>The transformAtoB matrix will now transform from the nodeA object’s space to the nodeB object’s space.</p>
<h2>Bone bind pose matrices</h2>
<p>The bind pose matrix is the matrix that represents the position and orientation of a joint in its default pose. It is used as a reference for skinning, which is the process of deforming a mesh based on the movement of joints in a skeleton.</p>
<p>When an animation is played, each joint in the skeleton is transformed by its animation matrix. The bind pose matrix is then used to transform the vertices of the mesh into the space of the joint. This is done by multiplying each vertex by the inverse of the bind pose matrix for the joint it is associated with.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Vector3 worldSpacePosition{1, 2, 3};</div>
<div class="line"><span class="keyword">const</span> Matrix3x4 offsetMatrix = animatedModel-&gt;GetSkeleton().GetBone(0u)-&gt;offsetMatrix_;</div>
<div class="line"><span class="keyword">const</span> Vector3 localSpacePosition = offsetMatrix * worldSpacePosition;</div>
</div><!-- fragment --><h1>Quaternion operations</h1>
<p>Quaternion multiplication order is the same as with matrices. Here is an example to illustrate it:</p>
<div class="fragment"><div class="line"><span class="comment">// Make Vector3</span></div>
<div class="line"><span class="keyword">const</span> Vector3 vec3{1, 2, 3};</div>
<div class="line"><span class="comment">// Make quaternions</span></div>
<div class="line">Quaternion rotationY{90.0f, Vector3::UP};</div>
<div class="line">Quaternion rotationX{90.0f, Vector3::RIGHT};</div>
<div class="line"><span class="comment">// Transform vector by quaternions</span></div>
<div class="line">Vector3 expl = rotationY * (rotationX * vec3); <span class="comment">//2,-3,-1</span></div>
<div class="line">Vector3 yx = (rotationY * rotationX) * vec3; <span class="comment">//2,-3,-1</span></div>
<div class="line">Vector3 xy = (rotationX * rotationY) * vec3; <span class="comment">//3,1,2</span></div>
</div><!-- fragment --><p>To reverse rotation take result of the Inverse() method: </p><div class="fragment"><div class="line"><span class="comment">// Make Vector3</span></div>
<div class="line"><span class="keyword">const</span> Vector3 vec3{1, 2, 3};</div>
<div class="line"><span class="comment">// Make quaternions</span></div>
<div class="line">Quaternion rotationY{90.0f, Vector3::UP};</div>
<div class="line">Quaternion rotationNegY = rotationY.Inverse();</div>
<div class="line"><span class="comment">// Transform vector by quaternions</span></div>
<div class="line">Vector3 rot = rotationY * vec3; <span class="comment">//3,2,-1</span></div>
<div class="line">Vector3 invRot = rotationNegY * vec3; <span class="comment">//-3,2,1</span></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
    <ul>
    </ul>
</div>
</body>
</html>
