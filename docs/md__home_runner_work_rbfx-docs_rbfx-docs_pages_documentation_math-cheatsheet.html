<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rebel Fork Framework: Math Cheatsheet</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rebel Fork Framework
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__home_runner_work_rbfx-docs_rbfx-docs_pages_documentation_math-cheatsheet.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Math Cheatsheet </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Angles, radians and degrees</h1>
<p>Radians and degrees are two units of measurement for angles. A full circle is 360 degrees, while the same angle in radians is 2π. This means that 1 radian is equal to 180/π degrees, and 1 degree is equal to π/180 radians.</p>
<p>To convert an angle from degrees to radians, you can use the following formula: </p><div class="fragment"><div class="line">radians = degrees * M_DEGTORAD;</div>
</div><!-- fragment --><p>To convert an angle from radians to degrees, you can use the following formula: </p><div class="fragment"><div class="line">degrees = radians * M_RADTODEG;</div>
</div><!-- fragment --><p>The Urho3D::Atan2 function is a two-argument arctangent function that calculates the angle between the positive x-axis and the ray from the origin to the point (x, y) in the Cartesian plane. The result is given in degrees and is confined to the range (-180, 180].</p>
<p>The yaw angle is the angle between the positive x-axis and the projection of the direction vector onto the x-z plane. You can calculate the yaw angle from a direction vector using the Urho3D::Atan2 function as follows: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> angle = <a class="code" href="_math_defs_8h.html#a3a083bb08e1de7805912aafa7f087ebd">Urho3D::Atan2</a>(dir.z_, dir.x_);</div>
</div><!-- fragment --><p>Some Atan2 result values for reference: </p><div class="fragment"><div class="line">Atan2( 0.0f,  0.0f) =&gt;  0.0f</div>
<div class="line">Atan2( 0.0f,  1.0f) =&gt;  0.0f</div>
<div class="line">Atan2( 1.0f,  1.0f) =&gt; 45.0f</div>
<div class="line">Atan2( 1.0f,  0.0f) =&gt; 90.0f</div>
<div class="line">Atan2( 1.0f, -1.0f) =&gt; 135.0f</div>
<div class="line">Atan2(-1.0f, -1.0f) =&gt; -135.0f</div>
<div class="line">Atan2(-1.0f,  1.0f) =&gt; -45.0f</div>
</div><!-- fragment --><p>Here is a C++ function that clamps an angle value in degrees between -180 and 180 degrees:</p>
<div class="fragment"><div class="line">float ClampAngle(float angle)</div>
<div class="line">{</div>
<div class="line">    angle = Urho3D::Mod(angle, 360.0f);</div>
<div class="line">    if (angle &gt; 180.0f)</div>
<div class="line">        return angle - 360.0f;</div>
<div class="line">    if (angle &lt; -180.0f)</div>
<div class="line">        return angle + 360.0f;</div>
<div class="line">    return angle;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This function takes an angle value in degrees as an input and returns the clamped angle value between -180 and 180 degrees. The Urho3D::Mod function is used to calculate the remainder of the division of the angle by 360, which brings the angle value within the range of -360 to 360 degrees. Then, if the angle is greater than 180 degrees, 360 is subtracted from it to bring it within the desired range. Similarly, if the angle is less than -180 degrees, 360 is added to it to bring it within the desired range.</p>
<p>This clamping function is very useful when you add or subtract angles. It is not absolutely necessary but makes this easier to understand and also keeps value close to 0 for better precision.</p>
<h1>Interpolation</h1>
<p>Linear Interpolation (Lerp) is a mathematical function that is used to find a point some fraction of the way along a line between two endpoints. In other words, it is used to find a value between two values that are known.</p>
<div class="fragment"><div class="line">Vector3 vectorA{1, 0, 0};</div>
<div class="line">Vector3 vectorB{0, 1, 0};</div>
<div class="line"><span class="keywordtype">float</span> t = 0.2f;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">auto</span> res1 = vectorA.Lerp(vectorB, t); <span class="comment">// {0.8f, 0.2f, 0.0f}</span></div>
<div class="line"><span class="keyword">auto</span> res2 = <a class="code" href="_math_defs_8h.html#a881de829a2aa2700593840d5a6978046">Urho3D::Lerp</a>(vectorA, vectorB, t); <span class="comment">// {0.8f, 0.2f, 0.0f}</span></div>
</div><!-- fragment --><p>An easing function is a mathematical function that modifies the time value of an animation to create a more natural and smooth effect. It is used to change the rate of change of a parameter over time. Easing functions are mostly used in animations to change a component value in a defined period of time. You can move objects, change their colors, scales, rotations and anything you want simply using easing equations.</p>
<p>For example, if you have an animation that moves an object from point A to point B in a straight line, it will look very robotic and unnatural. But if you use an easing function to modify the time value of the animation, you can create a more natural and smooth effect.</p>
<p>There are many different types of easing functions, each with its own unique effect. Some common types include linear easing, quadratic easing, cubic easing, and elastic easing.</p>
<p>Here is an example of interpolation with easing: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> res1 = vectorA.Lerp(vectorB, Urho3D::BackInOut(t));</div>
</div><!-- fragment --><h1>Vector operations</h1>
<p>To convert one vector to another use the .To*Vector* operators. Here are few examples:</p>
<div class="fragment"><div class="line"><span class="comment">// Make IntVector2</span></div>
<div class="line"><span class="keyword">const</span> IntVector2 value{1, 2};</div>
<div class="line"><span class="comment">// Convert it to Vector2</span></div>
<div class="line"><span class="keyword">const</span> Vector2 vec2 = value.ToVector2();</div>
<div class="line"><span class="comment">// Convert it to Vector3, set Z component to 1</span></div>
<div class="line"><span class="keyword">const</span> Vector3 vec3 = value.ToVector3(1.0f);</div>
</div><!-- fragment --><p>To rotate vector by quaternion use the following:</p>
<div class="fragment"><div class="line"><span class="comment">// Make Vector3</span></div>
<div class="line"><span class="keyword">const</span> Vector3 vec3{1, 2, 3};</div>
<div class="line"><span class="comment">// Make Quaternion</span></div>
<div class="line"><span class="keyword">const</span> Quaternion quaternion(90, Vector3::UP);</div>
<div class="line"><span class="comment">// Rotate vector by quaternion</span></div>
<div class="line">Vector3 rotated = quaternion * vec3; <span class="comment">// The result is {3, 2, -1}</span></div>
</div><!-- fragment --><p>To transform vector with matrix use multiplication:</p>
<div class="fragment"><div class="line"><span class="comment">// Make Vector3</span></div>
<div class="line"><span class="keyword">const</span> Vector3 vec3{1, 2, 3};</div>
<div class="line"><span class="comment">// Make Matrix</span></div>
<div class="line"><span class="keyword">const</span> Matrix3 mat(90, Vector3::UP);</div>
<div class="line"><span class="comment">// Rotate vector by quaternion</span></div>
<div class="line">Vector3 rotated = mat * vec3; <span class="comment">// The result is {3, 2, -1}</span></div>
</div><!-- fragment --><p>If you use Matrix3x4 or Matrix4 but you only need to apply rotation and scale you can add a zero as W component and use multiplication:</p>
<div class="fragment"><div class="line"><span class="comment">// Make Vector3</span></div>
<div class="line"><span class="keyword">const</span> Vector3 vec3{1, 2, 3};</div>
<div class="line"><span class="comment">// Make Matrix</span></div>
<div class="line">Matrix3x4 mat{Matrix3{90.0f, Vector3::UP}};</div>
<div class="line">mat.SetTranslation(Vector3{10, 20, 30});</div>
<div class="line"><span class="comment">// Rotate and translate vector by matrix</span></div>
<div class="line">Vector3 translated = mat * vec3;  <span class="comment">// The result is {13, 22, 29}</span></div>
<div class="line"><span class="comment">// Rotate vector by matrix</span></div>
<div class="line">Vector3 rotated = mat * vec3.ToVector4(0.0f); <span class="comment">// The result is {3, 2, -1}</span></div>
</div><!-- fragment --><p>All rotations in the engine performed in a clockwise order. Here is what going to happen with a vector {x,y,z} if rotated around an axis at 90 degrees:</p>
<div class="fragment"><div class="line">Axis X (Vector::RIGHT):   { x, y, z } =&gt; { x,-z, y }</div>
<div class="line">Axis Y (Vector::UP):      { x, y, z } =&gt; { z, y,-x }</div>
<div class="line">Axis Z (Vector::FORWARD): { x, y, z } =&gt; {-y, x, z }</div>
</div><!-- fragment --><h1>Matrix operations</h1>
<p>In the engine, matrices are column-major (like in OpenGL) while in DirectX they are row-major.</p>
<p>In general, for a column-vector on the right (OpenGL convention), M1 * (M2 * (M3 * v)) = (M1 M2 M3) * v, i.e. the left-most matrix is at the root node while the right-most is at the leaf node.</p>
<div class="fragment"><div class="line"><span class="comment">// Make Vector3</span></div>
<div class="line"><span class="keyword">const</span> Vector3 vec3{1, 2, 3};</div>
<div class="line"><span class="comment">// Make rotation matrix</span></div>
<div class="line">Matrix3x4 rotation{Matrix3{90.0f, Vector3::UP}};</div>
<div class="line"><span class="comment">// Make translation matrix</span></div>
<div class="line">Matrix3x4 translation{Vector3{10,20,30}, Quaternion::IDENTITY, Vector3::ONE};</div>
<div class="line"><span class="comment">// Transform vector by matrix</span></div>
<div class="line">Vector3 rt = (rotation * translation) * vec3; <span class="comment">//33, 22, -11</span></div>
<div class="line">Vector3 expl = rotation * (translation * vec3); <span class="comment">//33, 22, -11</span></div>
<div class="line">Vector3 tr = (translation * rotation) * vec3; <span class="comment">//13, 22, 29</span></div>
</div><!-- fragment --><h2>Node transform matrices</h2>
<p>To combine world transform matrices to make a matrix that would transform from one game object space into another object space, you can multiply the inverse of the world transform matrix of the second object by the world transform matrix of the first object. This will give you a matrix that will transform from one object space to another object space.</p>
<p>Here is an example code: </p><div class="fragment"><div class="line">Matrix3x4 transformA = nodeA-&gt;GetWorldTransform();</div>
<div class="line">Matrix3x4 transformB = nodeB-&gt;GetWorldTransform();</div>
<div class="line">Matrix3x4 transformAtoB = transformB.Inverse() * transformA;</div>
<div class="line"><span class="keyword">const</span> Vector3 positionInA{1, 2, 3};</div>
<div class="line"><span class="keyword">const</span> Vector3 positionInB = transformAtoB * positionInA;</div>
</div><!-- fragment --><p>The transformAtoB matrix will now transform from the nodeA object’s space to the nodeB object’s space.</p>
<h2>Bone bind pose matrices</h2>
<p>The bind pose matrix is the matrix that represents the position and orientation of a joint in its default pose. It is used as a reference for skinning, which is the process of deforming a mesh based on the movement of joints in a skeleton.</p>
<p>When an animation is played, each joint in the skeleton is transformed by its animation matrix. The bind pose matrix is then used to transform the vertices of the mesh into the space of the joint. This is done by multiplying each vertex by the inverse of the bind pose matrix for the joint it is associated with.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> Vector3 bindSpacePosition{1, 2, 3};</div>
<div class="line"><span class="keyword">const</span> Matrix3x4 offsetMatrix = animatedModel-&gt;GetSkeleton().GetBone(0u)-&gt;offsetMatrix_;</div>
<div class="line"><span class="keyword">const</span> Vector3 localSpacePosition = offsetMatrix * bindSpacePosition;</div>
</div><!-- fragment --><h1>Quaternion operations</h1>
<p>Quaternion multiplication order is the same as with matrices. Here is an example to illustrate it:</p>
<div class="fragment"><div class="line"><span class="comment">// Make Vector3</span></div>
<div class="line"><span class="keyword">const</span> Vector3 vec3{1, 2, 3};</div>
<div class="line"><span class="comment">// Make quaternions</span></div>
<div class="line">Quaternion rotationY{90.0f, Vector3::UP};</div>
<div class="line">Quaternion rotationX{90.0f, Vector3::RIGHT};</div>
<div class="line"><span class="comment">// Transform vector by quaternions</span></div>
<div class="line">Vector3 expl = rotationY * (rotationX * vec3); <span class="comment">//2,-3,-1</span></div>
<div class="line">Vector3 yx = (rotationY * rotationX) * vec3; <span class="comment">//2,-3,-1</span></div>
<div class="line">Vector3 xy = (rotationX * rotationY) * vec3; <span class="comment">//3,1,2</span></div>
</div><!-- fragment --><p>To reverse rotation take result of the Inverse() method: </p><div class="fragment"><div class="line"><span class="comment">// Make Vector3</span></div>
<div class="line"><span class="keyword">const</span> Vector3 vec3{1, 2, 3};</div>
<div class="line"><span class="comment">// Make quaternions</span></div>
<div class="line">Quaternion rotationY{90.0f, Vector3::UP};</div>
<div class="line">Quaternion rotationNegY = rotationY.Inverse();</div>
<div class="line"><span class="comment">// Transform vector by quaternions</span></div>
<div class="line">Vector3 rot = rotationY * vec3; <span class="comment">//3,2,-1</span></div>
<div class="line">Vector3 invRot = rotationNegY * vec3; <span class="comment">//-3,2,1</span></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="a_math_defs_8h_html_a3a083bb08e1de7805912aafa7f087ebd"><div class="ttname"><a href="_math_defs_8h.html#a3a083bb08e1de7805912aafa7f087ebd">Urho3D::Atan2</a></div><div class="ttdeci">T Atan2(T y, T x)</div><div class="ttdef"><b>Definition:</b> MathDefs.h:187</div></div>
<div class="ttc" id="a_math_defs_8h_html_a881de829a2aa2700593840d5a6978046"><div class="ttname"><a href="_math_defs_8h.html#a881de829a2aa2700593840d5a6978046">Urho3D::Lerp</a></div><div class="ttdeci">T Lerp(T lhs, T rhs, U t)</div><div class="ttdef"><b>Definition:</b> MathDefs.h:80</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
    <ul>
    </ul>
</div>
</body>
</html>
